{"ast":null,"code":"/*! @name @brightcove/react-player-loader @version 1.3.0 @license Apache-2.0 */\nimport React from 'react';\nimport document from 'global/document';\nimport window from 'global/window';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/*! @name @brightcove/player-loader @version 1.7.1 @license Apache-2.0 */\n\n\nfunction _extends$1() {\n  _extends$1 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends$1.apply(this, arguments);\n}\n\nvar version = \"1.7.1\";\n/*! @name @brightcove/player-url @version 1.2.0 @license Apache-2.0 */\n\nvar version$1 = \"1.2.0\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n}; // The parameters that may include JSON.\n\n\nvar JSON_ALLOWED_PARAMS = ['catalogSearch', 'catalogSequence']; // The parameters that may be set as query string parameters for iframes.\n\nvar IFRAME_ALLOWED_QUERY_PARAMS = ['adConfigId', 'applicationId', 'catalogSearch', 'catalogSequence', 'playlistId', 'playlistVideoId', 'videoId'];\n/**\n * Gets the value of a parameter and encodes it as a string.\n *\n * For certain keys, JSON is allowed and will be encoded.\n *\n * @private\n * @param   {Object} params\n *          A parameters object. See README for details.\n *\n * @param   {string} key\n *          The key in the params object.\n *\n * @return  {string|undefined}\n *          The encoded value - or `undefined` if none.\n */\n\nvar getQueryParamValue = function getQueryParamValue(params, key) {\n  if (!params || params[key] === undefined) {\n    return;\n  } // If it's not a string, such as with a catalog search or sequence, we\n  // try to encode it as JSON.\n\n\n  if (typeof params[key] !== 'string' && JSON_ALLOWED_PARAMS.indexOf(key) !== -1) {\n    try {\n      return encodeURIComponent(JSON.stringify(params[key]));\n    } catch (x) {\n      // If it's not a string and we can't encode as JSON, it's ignored entirely.\n      return;\n    }\n  }\n\n  return encodeURIComponent(String(params[key]).trim()) || undefined;\n};\n/**\n * In some cases, we need to add query string parameters to an iframe URL.\n *\n * @private\n * @param   {Object} params\n *          An object of query parameters.\n *\n * @return  {string}\n *          A query string starting with `?`. If no valid parameters are given,\n *          returns an empty string.\n */\n\n\nvar getQueryString = function getQueryString(params) {\n  return Object.keys(params).filter(function (k) {\n    return IFRAME_ALLOWED_QUERY_PARAMS.indexOf(k) !== -1;\n  }).reduce(function (qs, k) {\n    var value = getQueryParamValue(params, k);\n\n    if (value !== undefined) {\n      qs += qs ? '&' : '?';\n      qs += encodeURIComponent(k) + '=' + value;\n    }\n\n    return qs;\n  }, '');\n};\n/**\n * Generate a URL to a Brightcove Player.\n *\n * @param  {Object}  params\n *         A set of parameters describing the player URL to create.\n *\n * @param  {string}  params.accountId\n *         A Brightcove account ID.\n *\n * @param  {string}  [params.playerId=\"default\"]\n *         A Brightcove player ID.\n *\n * @param  {string}  [params.embedId=\"default\"]\n *         A Brightcove player embed ID.\n *\n * @param  {boolean} [params.iframe=false]\n *         Whether to return a URL for an HTML document to be embedded in\n *         an iframe.\n *\n * @param  {boolean} [params.minified=true]\n *         When the `iframe` argument is `false`, this can be used to control\n *         whether the minified or unminified JavaScript URL is returned.\n *\n * @param  {string} [params.base=\"https://players.brightcove.net\"]\n *         A base CDN protocol and hostname. Mainly used for testing.\n *\n * @return {string}\n *         A URL to a Brightcove Player.\n */\n\n\nvar brightcovePlayerUrl = function brightcovePlayerUrl(_ref) {\n  var accountId = _ref.accountId,\n      _ref$base = _ref.base,\n      base = _ref$base === undefined ? 'https://players.brightcove.net' : _ref$base,\n      _ref$playerId = _ref.playerId,\n      playerId = _ref$playerId === undefined ? 'default' : _ref$playerId,\n      _ref$embedId = _ref.embedId,\n      embedId = _ref$embedId === undefined ? 'default' : _ref$embedId,\n      _ref$iframe = _ref.iframe,\n      iframe = _ref$iframe === undefined ? false : _ref$iframe,\n      _ref$minified = _ref.minified,\n      minified = _ref$minified === undefined ? true : _ref$minified,\n      _ref$queryParams = _ref.queryParams,\n      queryParams = _ref$queryParams === undefined ? null : _ref$queryParams;\n  var ext = '';\n\n  if (iframe) {\n    ext += 'html';\n  } else {\n    if (minified) {\n      ext += 'min.';\n    }\n\n    ext += 'js';\n  }\n\n  if (base.charAt(base.length - 1) === '/') {\n    base = base.substring(0, base.length - 1);\n  }\n\n  var qs = '';\n\n  if (iframe && queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) === 'object') {\n    qs = getQueryString(queryParams);\n  }\n\n  accountId = encodeURIComponent(accountId);\n  playerId = encodeURIComponent(playerId);\n  embedId = encodeURIComponent(embedId);\n  return base + '/' + accountId + '/' + playerId + '_' + embedId + '/index.' + ext + qs;\n};\n/**\n * The version of this module.\n *\n * @type {string}\n */\n\n\nbrightcovePlayerUrl.VERSION = version$1;\nvar DEFAULTS = {\n  embedId: 'default',\n  embedType: 'in-page',\n  playerId: 'default',\n  Promise: window.Promise,\n  refNodeInsert: 'append'\n};\nvar DEFAULT_ASPECT_RATIO = '16:9';\nvar DEFAULT_IFRAME_HORIZONTAL_PLAYLIST = false;\nvar DEFAULT_MAX_WIDTH = '100%';\nvar EMBED_TAG_NAME_VIDEO = 'video';\nvar EMBED_TAG_NAME_VIDEOJS = 'video-js';\nvar EMBED_TYPE_IN_PAGE = 'in-page';\nvar EMBED_TYPE_IFRAME = 'iframe';\nvar REF_NODE_INSERT_APPEND = 'append';\nvar REF_NODE_INSERT_PREPEND = 'prepend';\nvar REF_NODE_INSERT_BEFORE = 'before';\nvar REF_NODE_INSERT_AFTER = 'after';\nvar REF_NODE_INSERT_REPLACE = 'replace';\nvar JSON_ALLOWED_ATTRS = ['catalogSearch', 'catalogSequence'];\nvar BASE_URL = 'https://players.brightcove.net/';\n/**\n * Gets the URL to a player on CDN.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {string}\n *         A URL.\n */\n\nvar getUrl = function getUrl(params) {\n  if (params.playerUrl) {\n    return params.playerUrl;\n  }\n\n  var accountId = params.accountId,\n      playerId = params.playerId,\n      embedId = params.embedId,\n      embedOptions = params.embedOptions;\n  var iframe = params.embedType === EMBED_TYPE_IFRAME;\n  return brightcovePlayerUrl({\n    accountId: accountId,\n    playerId: playerId,\n    embedId: embedId,\n    iframe: iframe,\n    base: BASE_URL,\n    // The unminified embed option is the exact reverse of the minified option\n    // here.\n    minified: embedOptions ? !embedOptions.unminified : true,\n    // Pass the entire params object as query params. This is safe because\n    // @brightcove/player-url only accepts a whitelist of parameters. Anything\n    // else will be ignored.\n    queryParams: params\n  });\n};\n/**\n * Function used to get the base URL - primarily for testing.\n *\n * @private\n * @return {string}\n *         The current base URL.\n */\n\n\nvar getBaseUrl = function getBaseUrl() {\n  return BASE_URL;\n};\n/**\n * Function used to set the base URL - primarily for testing.\n *\n * @private\n * @param {string} baseUrl\n *        A new base URL (instead of Brightcove CDN).\n */\n\n\nvar setBaseUrl = function setBaseUrl(baseUrl) {\n  BASE_URL = baseUrl;\n};\n\nvar urls = {\n  getUrl: getUrl,\n  getBaseUrl: getBaseUrl,\n  setBaseUrl: setBaseUrl\n};\n/**\n * Is this value an element?\n *\n * @param  {Element} el\n *         A maybe element.\n *\n * @return {boolean}\n *         Whether or not the value is a element.\n */\n\nvar isEl = function isEl(el) {\n  return Boolean(el && el.nodeType === 1);\n};\n/**\n * Is this value an element with a parent node?\n *\n * @param  {Element} el\n *         A maybe element.\n *\n * @return {boolean}\n *         Whether or not the value is a element with a parent node.\n */\n\n\nvar isElInDom = function isElInDom(el) {\n  return Boolean(isEl(el) && el.parentNode);\n};\n/**\n * Creates an iframe embed code.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()` function.\n */\n\n\nvar createIframeEmbed = function createIframeEmbed(params) {\n  var el = document.createElement('iframe');\n  el.setAttribute('allow', 'autoplay;encrypted-media;fullscreen');\n  el.setAttribute('allowfullscreen', 'allowfullscreen');\n  el.src = urls.getUrl(params);\n  return el;\n};\n/**\n * Creates an in-page embed code.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()` function.\n */\n\n\nvar createInPageEmbed = function createInPageEmbed(params) {\n  var embedOptions = params.embedOptions; // We DO NOT include the data-account, data-player, or data-embed attributes\n  // here because we will be manually initializing the player.\n\n  var paramsToAttrs = {\n    adConfigId: 'data-ad-config-id',\n    applicationId: 'data-application-id',\n    catalogSearch: 'data-catalog-search',\n    catalogSequence: 'data-catalog-sequence',\n    deliveryConfigId: 'data-delivery-config-id',\n    playlistId: 'data-playlist-id',\n    playlistVideoId: 'data-playlist-video-id',\n    videoId: 'data-video-id'\n  };\n  var tagName = embedOptions && embedOptions.tagName || EMBED_TAG_NAME_VIDEOJS;\n  var el = document.createElement(tagName);\n  Object.keys(paramsToAttrs).filter(function (key) {\n    return params[key];\n  }).forEach(function (key) {\n    var value; // If it's not a string, such as with a catalog search or sequence, we\n    // try to encode it as JSON.\n\n    if (typeof params[key] !== 'string' && JSON_ALLOWED_ATTRS.indexOf(key) !== -1) {\n      try {\n        value = JSON.stringify(params[key]); // If it fails, don't set anything.\n      } catch (x) {\n        return;\n      }\n    } else {\n      value = String(params[key]).trim();\n    }\n\n    el.setAttribute(paramsToAttrs[key], value);\n  });\n  el.setAttribute('controls', 'controls');\n  el.classList.add('video-js');\n  return el;\n};\n/**\n * Wraps an element in responsive intrinsic ratio elements.\n *\n * @private\n * @param  {string} embedType\n *         The type of the embed.\n *\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} el\n *         The DOM element.\n *\n * @return {Element}\n *         A new element (if needed).\n */\n\n\nvar wrapResponsive = function wrapResponsive(embedType, embedOptions, el) {\n  if (!embedOptions.responsive) {\n    return el;\n  }\n\n  el.style.position = 'absolute';\n  el.style.top = '0px';\n  el.style.right = '0px';\n  el.style.bottom = '0px';\n  el.style.left = '0px';\n  el.style.width = '100%';\n  el.style.height = '100%';\n\n  var responsive = _extends$1({\n    aspectRatio: DEFAULT_ASPECT_RATIO,\n    iframeHorizontalPlaylist: DEFAULT_IFRAME_HORIZONTAL_PLAYLIST,\n    maxWidth: DEFAULT_MAX_WIDTH\n  }, embedOptions.responsive); // This value is validate at a higher level, so we can trust that it's in the\n  // correct format.\n\n\n  var aspectRatio = responsive.aspectRatio.split(':').map(Number);\n  var inner = document.createElement('div');\n  var paddingTop = aspectRatio[1] / aspectRatio[0] * 100; // For iframes with a horizontal playlist, the playlist takes up 20% of the\n  // vertical space (if shown); so, adjust the vertical size of the embed to\n  // avoid black bars.\n\n  if (embedType === EMBED_TYPE_IFRAME && responsive.iframeHorizontalPlaylist) {\n    paddingTop *= 1.25;\n  }\n\n  inner.style.paddingTop = paddingTop + '%';\n  inner.appendChild(el);\n  var outer = document.createElement('div');\n  outer.style.position = 'relative';\n  outer.style.display = 'block';\n  outer.style.maxWidth = responsive.maxWidth;\n  outer.appendChild(inner);\n  return outer;\n};\n/**\n * Wraps an element in a Picture-in-Picture plugin container.\n *\n * @private\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} el\n *         The DOM element.\n *\n * @return {Element}\n *         A new element (if needed).\n */\n\n\nvar wrapPip = function wrapPip(embedOptions, el) {\n  if (!embedOptions.pip) {\n    return el;\n  }\n\n  var pip = document.createElement('div');\n  pip.classList.add('vjs-pip-container');\n  pip.appendChild(el);\n  return pip;\n};\n/**\n * Wraps a bare embed element with necessary parent elements, depending on\n * embed options given in params.\n *\n * @private\n * @param  {string} embedType\n *         The type of the embed.\n *\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         A new element (if needed) or the embed itself.\n */\n\n\nvar wrapEmbed = function wrapEmbed(embedType, embedOptions, embed) {\n  if (!embedOptions) {\n    return embed;\n  }\n\n  return wrapPip(embedOptions, wrapResponsive(embedType, embedOptions, embed));\n};\n/**\n * Inserts a previously-created embed element into the page based on params.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         The embed DOM element.\n */\n\n\nvar insertEmbed = function insertEmbed(params, embed) {\n  var refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert;\n  var refNodeParent = refNode.parentNode; // Wrap the embed, if needed, in container elements to support various\n  // plugins.\n\n  var wrapped = wrapEmbed(params.embedType, params.embedOptions, embed); // Decide where to insert the wrapped embed.\n\n  if (refNodeInsert === REF_NODE_INSERT_BEFORE) {\n    refNodeParent.insertBefore(wrapped, refNode);\n  } else if (refNodeInsert === REF_NODE_INSERT_AFTER) {\n    refNodeParent.insertBefore(wrapped, refNode.nextElementSibling || null);\n  } else if (refNodeInsert === REF_NODE_INSERT_REPLACE) {\n    refNodeParent.replaceChild(wrapped, refNode);\n  } else if (refNodeInsert === REF_NODE_INSERT_PREPEND) {\n    refNode.insertBefore(wrapped, refNode.firstChild || null); // Append is the default.\n  } else {\n    refNode.appendChild(wrapped);\n  } // If the playlist embed option is provided, we need to add a playlist element\n  // immediately after the embed. This has to happen after the embed is inserted\n  // into the DOM (above).\n\n\n  if (params.embedOptions && params.embedOptions.playlist) {\n    var playlistTagName = params.embedOptions.playlist.legacy ? 'ul' : 'div';\n    var playlist = document.createElement(playlistTagName);\n    playlist.classList.add('vjs-playlist');\n    embed.parentNode.insertBefore(playlist, embed.nextElementSibling || null);\n  } // Clean up internal reference to the refNode to avoid potential memory\n  // leaks in case the params get persisted somewhere. We won't need it beyond\n  // this point.\n\n\n  params.refNode = null; // Return the original embed element that can be passed to `bc()`.\n\n  return embed;\n};\n/**\n * Handles `onEmbedCreated` callback invocation.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         A possibly-new DOM element.\n */\n\n\nvar onEmbedCreated = function onEmbedCreated(params, embed) {\n  if (typeof params.onEmbedCreated !== 'function') {\n    return embed;\n  }\n\n  var result = params.onEmbedCreated(embed);\n\n  if (isEl(result)) {\n    return result;\n  }\n\n  return embed;\n};\n/**\n * Creates an embed code of the appropriate type, runs any customizations\n * necessary, and inserts it into the DOM.\n *\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()`\n *         function. Even when customized or wrapped, the return value will be\n *         the target element.\n */\n\n\nvar createEmbed = function createEmbed(params) {\n  var embed = params.embedType === EMBED_TYPE_IFRAME ? createIframeEmbed(params) : createInPageEmbed(params);\n  return insertEmbed(params, onEmbedCreated(params, embed));\n}; //\n// The keys follow the format \"accountId_playerId_embedId\" where accountId is\n// optional and defaults to \"*\". This happens when we detect pre-existing\n// player globals.\n\n\nvar actualCache = new window.Map();\n/**\n * Get the cache key given some properties.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {string}\n *         A key to be used in the script cache.\n */\n\nvar key = function key(_ref) {\n  var accountId = _ref.accountId,\n      playerId = _ref.playerId,\n      embedId = _ref.embedId;\n  return (accountId || '*') + \"_\" + playerId + \"_\" + embedId;\n};\n/**\n * Add an entry to the script cache.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID. If not given, we assume that no script was\n *         downloaded for this player.\n */\n\n\nvar store = function store(props) {\n  actualCache.set(key(props), props.accountId ? urls.getUrl(props) : '');\n};\n/**\n * Checks if the script cache has an entry.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {boolean}\n *         Will be `true` if there is a matching cache entry.\n */\n\n\nvar has = function has(props) {\n  return actualCache.has(key(props));\n};\n/**\n * Gets a cache entry.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {string}\n *         A cache entry - a URL or empty string.\n *\n */\n\n\nvar get = function get(props) {\n  return actualCache.get(key(props));\n};\n/**\n * Clears the cache.\n */\n\n\nvar clear = function clear() {\n  actualCache.clear();\n};\n/**\n * Iterates over the cache.\n *\n * @param  {Function} fn\n *         A callback function that will be called with a value and a key\n *         for each item in the cache.\n */\n\n\nvar forEach = function forEach(fn) {\n  actualCache.forEach(fn);\n};\n\nvar playerScriptCache = {\n  clear: clear,\n  forEach: forEach,\n  get: get,\n  has: has,\n  key: key,\n  store: store\n};\nvar REGEX_PLAYER_EMBED = /^([A-Za-z0-9]+)_([A-Za-z0-9]+)$/;\n/**\n * Gets an array of current per-player/per-embed `bc` globals that are\n * attached to the `bc` global (e.g. `bc.abc123xyz_default`).\n *\n * If `bc` is not defined, returns an empty array.\n *\n * @private\n * @return {string[]}\n *         An array of keys.\n */\n\nvar getBcGlobalKeys = function getBcGlobalKeys() {\n  return window.bc ? Object.keys(window.bc).filter(function (k) {\n    return REGEX_PLAYER_EMBED.test(k);\n  }) : [];\n};\n/**\n * Gets known global object keys that Brightcove Players may create.\n *\n * @private\n * @return {string[]}\n *         An array of global variables that were added during testing.\n */\n\n\nvar getGlobalKeys = function getGlobalKeys() {\n  return Object.keys(window).filter(function (k) {\n    return /^videojs/i.test(k) || /^(bc)$/.test(k);\n  });\n};\n/**\n * Dispose all players from a copy of Video.js.\n *\n * @param  {Function} videojs\n *         A copy of Video.js.\n */\n\n\nvar disposeAll = function disposeAll(videojs) {\n  if (!videojs) {\n    return;\n  }\n\n  Object.keys(videojs.players).forEach(function (k) {\n    var p = videojs.players[k];\n\n    if (p) {\n      p.dispose();\n    }\n  });\n};\n/**\n * Resets environment state.\n *\n * This will dispose ALL Video.js players on the page and remove ALL `bc` and\n * `videojs` globals it finds.\n */\n\n\nvar reset = function reset() {\n  // Remove all script elements from the DOM.\n  playerScriptCache.forEach(function (value, key) {\n    // If no script URL is associated, skip it.\n    if (!value) {\n      return;\n    } // Find all script elements and remove them.\n\n\n    Array.prototype.slice.call(document.querySelectorAll(\"script[src=\\\"\" + value + \"\\\"]\")).forEach(function (el) {\n      return el.parentNode.removeChild(el);\n    });\n  }); // Clear the internal cache that have been downloaded.\n\n  playerScriptCache.clear(); // Dispose any remaining players from the `videojs` global.\n\n  disposeAll(window.videojs); // There may be other `videojs` instances lurking in the bowels of the\n  // `bc` global. This should eliminate any of those.\n\n  getBcGlobalKeys().forEach(function (k) {\n    return disposeAll(window.bc[k].videojs);\n  }); // Delete any global object keys that were created.\n\n  getGlobalKeys().forEach(function (k) {\n    delete window[k];\n  });\n};\n/**\n * At runtime, populate the cache with pre-detected players. This allows\n * people who have bundled their player or included a script tag before this\n * runs to not have to re-download players.\n */\n\n\nvar detectPlayers = function detectPlayers() {\n  getBcGlobalKeys().forEach(function (k) {\n    var matches = k.match(REGEX_PLAYER_EMBED);\n    var props = {\n      playerId: matches[1],\n      embedId: matches[2]\n    };\n\n    if (!playerScriptCache.has(props)) {\n      playerScriptCache.store(props);\n    }\n  });\n};\n\nvar env = {\n  detectPlayers: detectPlayers,\n  reset: reset\n};\nenv.detectPlayers();\n/**\n * Is this value a function?\n *\n * @private\n * @param  {Function} fn\n *         A maybe function.\n *\n * @return {boolean}\n *         Whether or not the value is a function.\n */\n\nvar isFn = function isFn(fn) {\n  return typeof fn === 'function';\n};\n/**\n * Checks whether an embedType parameter is valid.\n *\n * @private\n * @param  {string} embedType\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidEmbedType = function isValidEmbedType(embedType) {\n  return embedType === EMBED_TYPE_IN_PAGE || embedType === EMBED_TYPE_IFRAME;\n};\n/**\n * Checks whether an embedOptions.tagName parameter is valid.\n *\n * @private\n * @param  {string} tagName\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidTagName = function isValidTagName(tagName) {\n  return tagName === EMBED_TAG_NAME_VIDEOJS || tagName === EMBED_TAG_NAME_VIDEO;\n};\n/**\n * Checks whether a refNodeInsert parameter is valid.\n *\n * @private\n * @param  {string} refNodeInsert\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidRootInsert = function isValidRootInsert(refNodeInsert) {\n  return refNodeInsert === REF_NODE_INSERT_APPEND || refNodeInsert === REF_NODE_INSERT_PREPEND || refNodeInsert === REF_NODE_INSERT_BEFORE || refNodeInsert === REF_NODE_INSERT_AFTER || refNodeInsert === REF_NODE_INSERT_REPLACE;\n};\n/**\n * Checks parameters and throws an error on validation problems.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @throws {Error} If accountId is missing.\n * @throws {Error} If refNode is missing or invalid.\n * @throws {Error} If embedType is missing or invalid.\n * @throws {Error} If attempting to use an iframe embed with options.\n * @throws {Error} If attempting to use embedOptions.responsiveIframe with a\n *                 non-iframe embed.\n * @throws {Error} If refNodeInsert is missing or invalid.\n */\n\n\nvar checkParams = function checkParams(params) {\n  var accountId = params.accountId,\n      embedOptions = params.embedOptions,\n      embedType = params.embedType,\n      options = params.options,\n      refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert;\n\n  if (!accountId) {\n    throw new Error('accountId is required');\n  } else if (!isElInDom(refNode)) {\n    throw new Error('refNode must resolve to a node attached to the DOM');\n  } else if (!isValidEmbedType(embedType)) {\n    throw new Error('embedType is missing or invalid');\n  } else if (embedType === EMBED_TYPE_IFRAME && options) {\n    throw new Error('cannot use options with an iframe embed');\n  } else if (embedOptions && embedOptions.tagName !== undefined && !isValidTagName(embedOptions.tagName)) {\n    throw new Error(\"embedOptions.tagName is invalid (value: \\\"\" + embedOptions.tagName + \"\\\")\");\n  } else if (embedOptions && embedOptions.responsive && embedOptions.responsive.aspectRatio && !/^\\d+\\:\\d+$/.test(embedOptions.responsive.aspectRatio)) {\n    throw new Error(\"embedOptions.responsive.aspectRatio must be in the \\\"n:n\\\" format (value: \\\"\" + embedOptions.responsive.aspectRatio + \"\\\")\");\n  } else if (!isValidRootInsert(refNodeInsert)) {\n    throw new Error('refNodeInsert is missing or invalid');\n  }\n};\n/**\n * Normalizes a `refNode` param to an element - or `null`.\n *\n * @private\n * @param  {Element|string} refNode\n *         The value of a `refNode` param.\n *\n * @return {Element|null}\n *         A DOM element or `null` if the `refNode` was given as a string and\n *         did not match an element.\n */\n\n\nvar resolveRefNode = function resolveRefNode(refNode) {\n  if (isElInDom(refNode)) {\n    return refNode;\n  }\n\n  if (typeof refNode === 'string') {\n    return document.querySelector(refNode);\n  }\n\n  return null;\n};\n/**\n * Initializes a player and returns it.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         An element that will be passed to the `bc()` function.\n *\n * @param  {Function} resolve\n *         A function to call if a player is successfully initialized.\n *\n * @param  {Function} reject\n *         A function to call if a player fails to be initialized.\n *\n * @return {Object}\n *         A success object whose `ref` is a player.\n */\n\n\nvar initPlayer = function initPlayer(params, embed, resolve, reject) {\n  var embedId = params.embedId,\n      playerId = params.playerId;\n  var bc = window.bc[playerId + \"_\" + embedId] || window.bc;\n\n  if (!bc) {\n    return reject(new Error(\"missing bc function for \" + playerId));\n  }\n\n  playerScriptCache.store(params);\n  var player;\n\n  try {\n    player = bc(embed, params.options); // Add a PLAYER_LOADER property to bcinfo to indicate this player was\n    // loaded via that mechanism.\n\n    if (player.bcinfo) {\n      player.bcinfo.PLAYER_LOADER = true;\n    }\n  } catch (x) {\n    var message = 'Could not initialize the Brightcove Player.'; // Update the rejection message based on known conditions that can cause it.\n\n    if (params.embedOptions.tagName === EMBED_TAG_NAME_VIDEOJS) {\n      message += ' You are attempting to embed using a \"video-js\" element.' + ' Please ensure that your Player is v6.11.0 or newer in order to' + ' support this embed type. Alternatively, pass `\"video\"` for' + ' `embedOptions.tagName`.';\n    }\n\n    return reject(new Error(message));\n  }\n\n  resolve({\n    type: EMBED_TYPE_IN_PAGE,\n    ref: player\n  });\n};\n/**\n * Loads a player from CDN and embeds it.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Function} resolve\n *         A function to call if a player is successfully initialized.\n *\n * @param  {Function} reject\n *         A function to call if a player fails to be initialized.\n */\n\n\nvar loadPlayer = function loadPlayer(params, resolve, reject) {\n  params.refNode = resolveRefNode(params.refNode);\n  checkParams(params);\n  var refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert; // Store a reference to the refNode parent. When we use the replace method,\n  // we'll need it as the location to store the script element.\n\n  var refNodeParent = refNode.parentNode;\n  var embed = createEmbed(params); // If this is an iframe, all we need to do is create the embed code and\n  // inject it. Because there is no reliable way to hook into an iframe from\n  // the parent page, we simply resolve immediately upon creating the embed.\n\n  if (params.embedType === EMBED_TYPE_IFRAME) {\n    resolve({\n      type: EMBED_TYPE_IFRAME,\n      ref: embed\n    });\n    return;\n  } // If we've already downloaded this script or detected a matching global, we\n  // should have the proper `bc` global and can bypass the script creation\n  // process.\n\n\n  if (playerScriptCache.has(params)) {\n    return initPlayer(params, embed, resolve, reject);\n  }\n\n  var script = document.createElement('script');\n\n  script.onload = function () {\n    return initPlayer(params, embed, resolve, reject);\n  };\n\n  script.onerror = function () {\n    reject(new Error('player script could not be downloaded'));\n  };\n\n  script.async = true;\n  script.charset = 'utf-8';\n  script.src = urls.getUrl(params);\n\n  if (refNodeInsert === REF_NODE_INSERT_REPLACE) {\n    refNodeParent.appendChild(script);\n  } else {\n    refNode.appendChild(script);\n  }\n};\n/**\n * A function for asynchronously loading a Brightcove Player into a web page.\n *\n * @param  {Object} parameters\n *         A parameters object. See README for details.\n *\n * @return {Promise|undefined}\n *         A Promise, if possible.\n */\n\n\nvar brightcovePlayerLoader = function brightcovePlayerLoader(parameters) {\n  var params = _extends$1({}, DEFAULTS, parameters);\n\n  var Promise = params.Promise,\n      onSuccess = params.onSuccess,\n      onFailure = params.onFailure; // When Promise is not available or any success/failure callback is given,\n  // do not attempt to use Promises.\n\n  if (!isFn(Promise) || isFn(onSuccess) || isFn(onFailure)) {\n    return loadPlayer(params, isFn(onSuccess) ? onSuccess : function () {}, isFn(onFailure) ? onFailure : function (err) {\n      throw err;\n    });\n  } // Promises are supported, use 'em.\n\n\n  return new Promise(function (resolve, reject) {\n    return loadPlayer(params, resolve, reject);\n  });\n};\n/**\n * Expose a non-writable, non-configurable property on the\n * `brightcovePlayerLoader` function.\n *\n * @private\n * @param  {string} key\n *         The property key.\n *\n * @param  {string|Function} value\n *         The value.\n */\n\n\nvar expose = function expose(key, value) {\n  Object.defineProperty(brightcovePlayerLoader, key, {\n    configurable: false,\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n};\n/**\n * Get the base URL for players. By default, this will be the Brightcove CDN.\n *\n * @return {string}\n *         The current base URL.\n */\n\n\nexpose('getBaseUrl', function () {\n  return urls.getBaseUrl();\n});\n/**\n * Set the base URL for players. By default, this will be the Brightcove CDN,\n * but can be overridden with this function.\n *\n * @param {string} baseUrl\n *        A new base URL (instead of Brightcove CDN).\n */\n\nexpose('setBaseUrl', function (baseUrl) {\n  urls.setBaseUrl(baseUrl);\n});\n/**\n * Get the URL for a player.\n */\n\nexpose('getUrl', function (options) {\n  return urls.getUrl(options);\n});\n/**\n * Completely resets global state.\n *\n * This will dispose ALL Video.js players on the page and remove ALL `bc` and\n * `videojs` globals it finds.\n */\n\nexpose('reset', function () {\n  return env.reset();\n}); // Define some read-only constants on the exported function.\n\n[['EMBED_TAG_NAME_VIDEO', EMBED_TAG_NAME_VIDEO], ['EMBED_TAG_NAME_VIDEOJS', EMBED_TAG_NAME_VIDEOJS], ['EMBED_TYPE_IN_PAGE', EMBED_TYPE_IN_PAGE], ['EMBED_TYPE_IFRAME', EMBED_TYPE_IFRAME], ['REF_NODE_INSERT_APPEND', REF_NODE_INSERT_APPEND], ['REF_NODE_INSERT_PREPEND', REF_NODE_INSERT_PREPEND], ['REF_NODE_INSERT_BEFORE', REF_NODE_INSERT_BEFORE], ['REF_NODE_INSERT_AFTER', REF_NODE_INSERT_AFTER], ['REF_NODE_INSERT_REPLACE', REF_NODE_INSERT_REPLACE], ['VERSION', version]].forEach(function (arr) {\n  expose(arr[0], arr[1]);\n});\n/**\n * These prop changes can be handled by an internal player state change rather\n * than a full dispose/recreate.\n *\n * @private\n * @type {Object}\n */\n\nvar UPDATEABLE_PROPS = ['catalogSearch', 'catalogSequence', 'playlistId', 'playlistVideoId', 'videoId'];\n\nvar logError = function logError(err) {\n  /* eslint-disable no-console */\n  if (err && console && console.error) {\n    console.error(err);\n  }\n  /* eslint-enable no-console */\n\n};\n/**\n * The official React component for the Brightcove Player!\n *\n * This uses `@brightcove/player-loader` to load a player into a React\n * component based on the given props.\n */\n\n\nvar ReactPlayerLoader =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(ReactPlayerLoader, _React$Component);\n  /**\n   * Create a new Brightcove player.\n   *\n   * @param {Object} props\n   *        Most options will be passed along to player-loader, except for\n   *        options that are listed. See README.md for more detail.\n   *\n   * @param {string} [props.baseUrl]\n   *        The base URL to use when requesting a player\n   *\n   * @param {Object} [props.attrs]\n   *        Used to set attributes on the component element that contains the\n   *        embedded Brightcove Player.\n   */\n\n\n  function ReactPlayerLoader(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.refNode = null;\n\n    _this.setRefNode = function (ref) {\n      _this.refNode = ref;\n    };\n\n    return _this;\n  }\n  /**\n   * Loads a new player based on the current props.\n   */\n\n\n  var _proto = ReactPlayerLoader.prototype;\n\n  _proto.loadPlayer = function loadPlayer() {\n    var _this2 = this; // If there is any player currently loaded, dispose it before fetching a\n    // new one.\n\n\n    this.disposePlayer(); // We need to provide our own callbacks below, so we cache these\n    // user-provided callbacks for use later.\n\n    var userSuccess = this.props.onSuccess;\n    var userFailure = this.props.onFailure;\n\n    var options = _extends({}, this.props, {\n      refNode: this.refNode,\n      refNodeInsert: 'append',\n      onSuccess: function onSuccess(_ref) {\n        var ref = _ref.ref,\n            type = _ref.type; // If the component is not mounted when the callback fires, dispose\n        // the player and bail out.\n\n        if (!_this2.isMounted_) {\n          _this2.disposePlayer(ref);\n\n          return;\n        } // Store a player reference on the component.\n\n\n        _this2.player = ref; // Null out the player reference when the player is disposed from\n        // outside the component.\n\n        if (type === 'in-page') {\n          ref.one('dispose', function () {\n            _this2.player = null;\n          });\n        } // Add a REACT_PLAYER_LOADER property to bcinfo to indicate this player\n        // was loaded via that mechanism.\n\n\n        if (ref.bcinfo) {\n          ref.bcinfo.REACT_PLAYER_LOADER = true;\n        } // Call a user-provided onSuccess callback.\n\n\n        if (typeof userSuccess === 'function') {\n          userSuccess({\n            ref: ref,\n            type: type\n          });\n        }\n      },\n      onFailure: function onFailure(error) {\n        // Ignore errors when not mounted.\n        if (!_this2.isMounted_) {\n          return;\n        } // Call a user-provided onFailure callback.\n\n\n        if (typeof userFailure === 'function') {\n          userFailure(error);\n          return;\n        } // Fall back to throwing an error;\n\n\n        throw new Error(error);\n      }\n    }); // Delete props that are not meant to be passed to player-loader.\n\n\n    delete options.attrs;\n    delete options.baseUrl; // If a base URL is provided, it should only apply to this player load.\n    // This means we need to back up the original base URL and restore it\n    // _after_ we call player loader.\n\n    var originalBaseUrl = brightcovePlayerLoader.getBaseUrl();\n\n    if (this.props.baseUrl) {\n      brightcovePlayerLoader.setBaseUrl(this.props.baseUrl);\n    }\n\n    brightcovePlayerLoader(options);\n    brightcovePlayerLoader.setBaseUrl(originalBaseUrl);\n  }\n  /**\n   * Disposes the current player, if there is one.\n   */\n  ;\n\n  _proto.disposePlayer = function disposePlayer() {\n    // Nothing to dispose.\n    if (!this.player) {\n      return;\n    } // Dispose an in-page player.\n\n\n    if (this.player.dispose) {\n      this.player.dispose(); // Dispose an iframe player.\n    } else if (this.player.parentNode) {\n      this.player.parentNode.removeChild(this.player);\n    } // Null out the player reference.\n\n\n    this.player = null;\n  }\n  /**\n   * Find the index of the `playlistVideoId` prop within the player's playlist.\n   *\n   * @param  {Object[]} playlist\n   *         An array of playlist item objects.\n   *\n   * @return {number}\n   *         The index of the `playlistVideoId` or `-1` if the player has been\n   *         disposed, is not using the playlist plugin, or if not found.\n   */\n  ;\n\n  _proto.findPlaylistVideoIdIndex_ = function findPlaylistVideoIdIndex_(playlist) {\n    var playlistVideoId = this.props.playlistVideoId;\n\n    if (Array.isArray(playlist) && playlistVideoId) {\n      for (var i = 0; i < playlist.length; i++) {\n        var _playlist$i = playlist[i],\n            id = _playlist$i.id,\n            referenceId = _playlist$i.referenceId;\n\n        if (id === playlistVideoId || \"ref:\" + referenceId === playlistVideoId) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Create a Playback API callback function for the component's player.\n   *\n   * @private\n   * @param  {string} requestType\n   *         The Playback API request type (e.g. \"video\" or \"playlist\").\n   *\n   * @param  {Object} changes\n   *         An object. The keys of this object are the props that changed.\n   *\n   * @return {Function}\n   *         A callback for the Playback API request.\n   */\n  ;\n\n  _proto.createPlaybackAPICallback_ = function createPlaybackAPICallback_(requestType, changes) {\n    var _this3 = this;\n\n    return function (err, data) {\n      if (err) {\n        logError(err);\n        return;\n      } // If the playlistVideoId changed and this is a playlist request, we\n      // need to search through the playlist items to find the correct\n      // starting index.\n\n\n      if (requestType === 'playlist' && changes.playlistVideoId) {\n        var i = _this3.findPlaylistVideoIdIndex_(data);\n\n        if (i > -1) {\n          data.startingIndex = i;\n        }\n      }\n\n      _this3.player.catalog.load(data);\n    };\n  }\n  /**\n   * Update the player based on changes to certain props that do not require\n   * a full player dispose/recreate.\n   *\n   * @param {Object} changes\n   *        An object. The keys of this object are the props that changed.\n   */\n  ;\n\n  _proto.updatePlayer = function updatePlayer(changes) {\n    // No player exists, player is disposed, or not using the catalog\n    if (!this.player || !this.player.el()) {\n      return;\n    } // If the player is using the catalog plugin, we _may_ populate this\n    // variable with an object.\n\n\n    var catalogParams;\n\n    if (this.player.usingPlugin('catalog')) {\n      // There is a new catalog sequence request. This takes precedence over\n      // other catalog updates because it is a different call.\n      if (changes.catalogSequence && this.props.catalogSequence) {\n        var callback = this.createPlaybackAPICallback_('sequence', changes);\n        this.player.catalog.getLazySequence(this.props.catalogSequence, callback, this.props.adConfigId);\n        return;\n      }\n\n      if (changes.videoId && this.props.videoId) {\n        catalogParams = {\n          type: 'video',\n          id: this.props.videoId\n        };\n      } else if (changes.playlistId && this.props.playlistId) {\n        catalogParams = {\n          type: 'playlist',\n          id: this.props.playlistId\n        };\n      } else if (changes.catalogSearch && this.props.catalogSearch) {\n        catalogParams = {\n          type: 'search',\n          q: this.props.catalogSearch\n        };\n      }\n    } // If `catalogParams` is `undefined` here, that means the player either\n    // does not have the catalog plugin or no valid catalog request can be made.\n\n\n    if (catalogParams) {\n      if (this.props.adConfigId) {\n        catalogParams.adConfigId = this.props.adConfigId;\n      }\n\n      if (this.props.deliveryConfigId) {\n        catalogParams.deliveryConfigId = this.props.deliveryConfigId;\n      } // We use the callback style here to make tests simpler in IE11 (no need\n      // for a Promise polyfill).\n\n\n      var _callback = this.createPlaybackAPICallback_(catalogParams.type, changes);\n\n      this.player.catalog.get(catalogParams, _callback); // If no catalog request is being made, we may still need to update the\n      // playlist selected video.\n    } else if (changes.playlistVideoId && this.props.playlistVideoId && this.player.usingPlugin('playlist')) {\n      var i = this.findPlaylistVideoIdIndex_(this.player.playlist());\n\n      if (i > -1) {\n        this.player.playlist.currentItem(i);\n      }\n    }\n  }\n  /**\n   * Called just after the component has mounted.\n   */\n  ;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.isMounted_ = true;\n    this.loadPlayer();\n  }\n  /**\n   * Called when the component props are updated.\n   *\n   * Some prop changes may trigger special behavior (see `propChangeHandlers`),\n   * but if ANY prop is changed that is NOT handled, the player will be\n   * disposed/recreated entirely.\n   *\n   * @param  {Object} prevProps\n   *         The previous props state before change.\n   */\n  ;\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this4 = this; // Calculate the prop changes.\n\n\n    var changes = Object.keys(prevProps).reduce(function (acc, key) {\n      var previous = prevProps[key];\n      var current = _this4.props[key];\n\n      if (current !== previous) {\n        acc[key] = true;\n      }\n\n      return acc;\n    }, {}); // Dispose and recreate the player if any changed keys cannot be handled.\n\n    if (Object.keys(changes).some(function (k) {\n      return UPDATEABLE_PROPS.indexOf(k) === -1;\n    })) {\n      this.loadPlayer();\n      return;\n    }\n\n    this.updatePlayer(changes);\n  }\n  /**\n   * Called just before a component unmounts. Disposes the player.\n   */\n  ;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.isMounted_ = false;\n    this.disposePlayer();\n  }\n  /**\n   * Renders the component.\n   *\n   * @return {ReactElement}\n   *          The react element to render.\n   */\n  ;\n\n  _proto.render = function render() {\n    var props = _extends({\n      className: 'brightcove-react-player-loader'\n    }, this.props.attrs, {\n      ref: this.setRefNode\n    });\n\n    return React.createElement('div', props);\n  };\n\n  return ReactPlayerLoader;\n}(React.Component);\n\nexport default ReactPlayerLoader;","map":{"version":3,"sources":["/projects/lordabbet/react-repo/captivate-common-lib/node_modules/@brightcove/react-player-loader/dist/brightcove-react-player-loader.es.js"],"names":["React","document","window","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_extends$1","version","version$1","_typeof","Symbol","iterator","obj","JSON_ALLOWED_PARAMS","IFRAME_ALLOWED_QUERY_PARAMS","getQueryParamValue","params","undefined","indexOf","encodeURIComponent","JSON","stringify","x","String","trim","getQueryString","keys","filter","k","reduce","qs","value","brightcovePlayerUrl","_ref","accountId","_ref$base","base","_ref$playerId","playerId","_ref$embedId","embedId","_ref$iframe","iframe","_ref$minified","minified","_ref$queryParams","queryParams","ext","charAt","substring","VERSION","DEFAULTS","embedType","Promise","refNodeInsert","DEFAULT_ASPECT_RATIO","DEFAULT_IFRAME_HORIZONTAL_PLAYLIST","DEFAULT_MAX_WIDTH","EMBED_TAG_NAME_VIDEO","EMBED_TAG_NAME_VIDEOJS","EMBED_TYPE_IN_PAGE","EMBED_TYPE_IFRAME","REF_NODE_INSERT_APPEND","REF_NODE_INSERT_PREPEND","REF_NODE_INSERT_BEFORE","REF_NODE_INSERT_AFTER","REF_NODE_INSERT_REPLACE","JSON_ALLOWED_ATTRS","BASE_URL","getUrl","playerUrl","embedOptions","unminified","getBaseUrl","setBaseUrl","baseUrl","urls","isEl","el","Boolean","nodeType","isElInDom","parentNode","createIframeEmbed","createElement","setAttribute","src","createInPageEmbed","paramsToAttrs","adConfigId","applicationId","catalogSearch","catalogSequence","deliveryConfigId","playlistId","playlistVideoId","videoId","tagName","forEach","classList","add","wrapResponsive","responsive","style","position","top","right","bottom","left","width","height","aspectRatio","iframeHorizontalPlaylist","maxWidth","split","map","Number","inner","paddingTop","appendChild","outer","display","wrapPip","pip","wrapEmbed","embed","insertEmbed","refNode","refNodeParent","wrapped","insertBefore","nextElementSibling","replaceChild","firstChild","playlist","playlistTagName","legacy","onEmbedCreated","result","createEmbed","actualCache","Map","store","props","set","has","get","clear","fn","playerScriptCache","REGEX_PLAYER_EMBED","getBcGlobalKeys","bc","test","getGlobalKeys","disposeAll","videojs","players","p","dispose","reset","Array","slice","querySelectorAll","removeChild","detectPlayers","matches","match","env","isFn","isValidEmbedType","isValidTagName","isValidRootInsert","checkParams","options","Error","resolveRefNode","querySelector","initPlayer","resolve","reject","player","bcinfo","PLAYER_LOADER","message","type","ref","loadPlayer","script","onload","onerror","async","charset","brightcovePlayerLoader","parameters","onSuccess","onFailure","err","expose","defineProperty","configurable","enumerable","writable","arr","UPDATEABLE_PROPS","logError","console","error","ReactPlayerLoader","_React$Component","_this","setRefNode","_proto","_this2","disposePlayer","userSuccess","userFailure","isMounted_","one","REACT_PLAYER_LOADER","attrs","originalBaseUrl","findPlaylistVideoIdIndex_","isArray","_playlist$i","id","referenceId","createPlaybackAPICallback_","requestType","changes","_this3","data","startingIndex","catalog","load","updatePlayer","catalogParams","usingPlugin","callback","getLazySequence","q","_callback","currentItem","componentDidMount","componentDidUpdate","prevProps","_this4","acc","previous","current","some","componentWillUnmount","render","className","Component"],"mappings":"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","sourcesContent":["/*! @name @brightcove/react-player-loader @version 1.3.0 @license Apache-2.0 */\nimport React from 'react';\nimport document from 'global/document';\nimport window from 'global/window';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\n/*! @name @brightcove/player-loader @version 1.7.1 @license Apache-2.0 */\n\nfunction _extends$1() {\n  _extends$1 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends$1.apply(this, arguments);\n}\n\nvar version = \"1.7.1\";\n\n/*! @name @brightcove/player-url @version 1.2.0 @license Apache-2.0 */\nvar version$1 = \"1.2.0\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n// The parameters that may include JSON.\nvar JSON_ALLOWED_PARAMS = ['catalogSearch', 'catalogSequence'];\n\n// The parameters that may be set as query string parameters for iframes.\nvar IFRAME_ALLOWED_QUERY_PARAMS = ['adConfigId', 'applicationId', 'catalogSearch', 'catalogSequence', 'playlistId', 'playlistVideoId', 'videoId'];\n\n/**\n * Gets the value of a parameter and encodes it as a string.\n *\n * For certain keys, JSON is allowed and will be encoded.\n *\n * @private\n * @param   {Object} params\n *          A parameters object. See README for details.\n *\n * @param   {string} key\n *          The key in the params object.\n *\n * @return  {string|undefined}\n *          The encoded value - or `undefined` if none.\n */\nvar getQueryParamValue = function getQueryParamValue(params, key) {\n\n  if (!params || params[key] === undefined) {\n    return;\n  }\n\n  // If it's not a string, such as with a catalog search or sequence, we\n  // try to encode it as JSON.\n  if (typeof params[key] !== 'string' && JSON_ALLOWED_PARAMS.indexOf(key) !== -1) {\n    try {\n      return encodeURIComponent(JSON.stringify(params[key]));\n    } catch (x) {\n\n      // If it's not a string and we can't encode as JSON, it's ignored entirely.\n      return;\n    }\n  }\n\n  return encodeURIComponent(String(params[key]).trim()) || undefined;\n};\n\n/**\n * In some cases, we need to add query string parameters to an iframe URL.\n *\n * @private\n * @param   {Object} params\n *          An object of query parameters.\n *\n * @return  {string}\n *          A query string starting with `?`. If no valid parameters are given,\n *          returns an empty string.\n */\nvar getQueryString = function getQueryString(params) {\n  return Object.keys(params).filter(function (k) {\n    return IFRAME_ALLOWED_QUERY_PARAMS.indexOf(k) !== -1;\n  }).reduce(function (qs, k) {\n    var value = getQueryParamValue(params, k);\n\n    if (value !== undefined) {\n      qs += qs ? '&' : '?';\n      qs += encodeURIComponent(k) + '=' + value;\n    }\n\n    return qs;\n  }, '');\n};\n\n/**\n * Generate a URL to a Brightcove Player.\n *\n * @param  {Object}  params\n *         A set of parameters describing the player URL to create.\n *\n * @param  {string}  params.accountId\n *         A Brightcove account ID.\n *\n * @param  {string}  [params.playerId=\"default\"]\n *         A Brightcove player ID.\n *\n * @param  {string}  [params.embedId=\"default\"]\n *         A Brightcove player embed ID.\n *\n * @param  {boolean} [params.iframe=false]\n *         Whether to return a URL for an HTML document to be embedded in\n *         an iframe.\n *\n * @param  {boolean} [params.minified=true]\n *         When the `iframe` argument is `false`, this can be used to control\n *         whether the minified or unminified JavaScript URL is returned.\n *\n * @param  {string} [params.base=\"https://players.brightcove.net\"]\n *         A base CDN protocol and hostname. Mainly used for testing.\n *\n * @return {string}\n *         A URL to a Brightcove Player.\n */\nvar brightcovePlayerUrl = function brightcovePlayerUrl(_ref) {\n  var accountId = _ref.accountId,\n      _ref$base = _ref.base,\n      base = _ref$base === undefined ? 'https://players.brightcove.net' : _ref$base,\n      _ref$playerId = _ref.playerId,\n      playerId = _ref$playerId === undefined ? 'default' : _ref$playerId,\n      _ref$embedId = _ref.embedId,\n      embedId = _ref$embedId === undefined ? 'default' : _ref$embedId,\n      _ref$iframe = _ref.iframe,\n      iframe = _ref$iframe === undefined ? false : _ref$iframe,\n      _ref$minified = _ref.minified,\n      minified = _ref$minified === undefined ? true : _ref$minified,\n      _ref$queryParams = _ref.queryParams,\n      queryParams = _ref$queryParams === undefined ? null : _ref$queryParams;\n\n  var ext = '';\n\n  if (iframe) {\n    ext += 'html';\n  } else {\n    if (minified) {\n      ext += 'min.';\n    }\n    ext += 'js';\n  }\n\n  if (base.charAt(base.length - 1) === '/') {\n    base = base.substring(0, base.length - 1);\n  }\n\n  var qs = '';\n\n  if (iframe && queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) === 'object') {\n    qs = getQueryString(queryParams);\n  }\n\n  accountId = encodeURIComponent(accountId);\n  playerId = encodeURIComponent(playerId);\n  embedId = encodeURIComponent(embedId);\n\n  return base + '/' + accountId + '/' + playerId + '_' + embedId + '/index.' + ext + qs;\n};\n\n/**\n * The version of this module.\n *\n * @type {string}\n */\nbrightcovePlayerUrl.VERSION = version$1;\n\nvar DEFAULTS = {\n  embedId: 'default',\n  embedType: 'in-page',\n  playerId: 'default',\n  Promise: window.Promise,\n  refNodeInsert: 'append'\n};\nvar DEFAULT_ASPECT_RATIO = '16:9';\nvar DEFAULT_IFRAME_HORIZONTAL_PLAYLIST = false;\nvar DEFAULT_MAX_WIDTH = '100%';\nvar EMBED_TAG_NAME_VIDEO = 'video';\nvar EMBED_TAG_NAME_VIDEOJS = 'video-js';\nvar EMBED_TYPE_IN_PAGE = 'in-page';\nvar EMBED_TYPE_IFRAME = 'iframe';\nvar REF_NODE_INSERT_APPEND = 'append';\nvar REF_NODE_INSERT_PREPEND = 'prepend';\nvar REF_NODE_INSERT_BEFORE = 'before';\nvar REF_NODE_INSERT_AFTER = 'after';\nvar REF_NODE_INSERT_REPLACE = 'replace';\nvar JSON_ALLOWED_ATTRS = ['catalogSearch', 'catalogSequence'];\n\nvar BASE_URL = 'https://players.brightcove.net/';\n/**\n * Gets the URL to a player on CDN.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {string}\n *         A URL.\n */\n\nvar getUrl = function getUrl(params) {\n  if (params.playerUrl) {\n    return params.playerUrl;\n  }\n\n  var accountId = params.accountId,\n      playerId = params.playerId,\n      embedId = params.embedId,\n      embedOptions = params.embedOptions;\n  var iframe = params.embedType === EMBED_TYPE_IFRAME;\n  return brightcovePlayerUrl({\n    accountId: accountId,\n    playerId: playerId,\n    embedId: embedId,\n    iframe: iframe,\n    base: BASE_URL,\n    // The unminified embed option is the exact reverse of the minified option\n    // here.\n    minified: embedOptions ? !embedOptions.unminified : true,\n    // Pass the entire params object as query params. This is safe because\n    // @brightcove/player-url only accepts a whitelist of parameters. Anything\n    // else will be ignored.\n    queryParams: params\n  });\n};\n/**\n * Function used to get the base URL - primarily for testing.\n *\n * @private\n * @return {string}\n *         The current base URL.\n */\n\n\nvar getBaseUrl = function getBaseUrl() {\n  return BASE_URL;\n};\n/**\n * Function used to set the base URL - primarily for testing.\n *\n * @private\n * @param {string} baseUrl\n *        A new base URL (instead of Brightcove CDN).\n */\n\n\nvar setBaseUrl = function setBaseUrl(baseUrl) {\n  BASE_URL = baseUrl;\n};\n\nvar urls = {\n  getUrl: getUrl,\n  getBaseUrl: getBaseUrl,\n  setBaseUrl: setBaseUrl\n};\n\n/**\n * Is this value an element?\n *\n * @param  {Element} el\n *         A maybe element.\n *\n * @return {boolean}\n *         Whether or not the value is a element.\n */\n\nvar isEl = function isEl(el) {\n  return Boolean(el && el.nodeType === 1);\n};\n/**\n * Is this value an element with a parent node?\n *\n * @param  {Element} el\n *         A maybe element.\n *\n * @return {boolean}\n *         Whether or not the value is a element with a parent node.\n */\n\n\nvar isElInDom = function isElInDom(el) {\n  return Boolean(isEl(el) && el.parentNode);\n};\n/**\n * Creates an iframe embed code.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()` function.\n */\n\n\nvar createIframeEmbed = function createIframeEmbed(params) {\n  var el = document.createElement('iframe');\n  el.setAttribute('allow', 'autoplay;encrypted-media;fullscreen');\n  el.setAttribute('allowfullscreen', 'allowfullscreen');\n  el.src = urls.getUrl(params);\n  return el;\n};\n/**\n * Creates an in-page embed code.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()` function.\n */\n\n\nvar createInPageEmbed = function createInPageEmbed(params) {\n  var embedOptions = params.embedOptions; // We DO NOT include the data-account, data-player, or data-embed attributes\n  // here because we will be manually initializing the player.\n\n  var paramsToAttrs = {\n    adConfigId: 'data-ad-config-id',\n    applicationId: 'data-application-id',\n    catalogSearch: 'data-catalog-search',\n    catalogSequence: 'data-catalog-sequence',\n    deliveryConfigId: 'data-delivery-config-id',\n    playlistId: 'data-playlist-id',\n    playlistVideoId: 'data-playlist-video-id',\n    videoId: 'data-video-id'\n  };\n  var tagName = embedOptions && embedOptions.tagName || EMBED_TAG_NAME_VIDEOJS;\n  var el = document.createElement(tagName);\n  Object.keys(paramsToAttrs).filter(function (key) {\n    return params[key];\n  }).forEach(function (key) {\n    var value; // If it's not a string, such as with a catalog search or sequence, we\n    // try to encode it as JSON.\n\n    if (typeof params[key] !== 'string' && JSON_ALLOWED_ATTRS.indexOf(key) !== -1) {\n      try {\n        value = JSON.stringify(params[key]); // If it fails, don't set anything.\n      } catch (x) {\n        return;\n      }\n    } else {\n      value = String(params[key]).trim();\n    }\n\n    el.setAttribute(paramsToAttrs[key], value);\n  });\n  el.setAttribute('controls', 'controls');\n  el.classList.add('video-js');\n  return el;\n};\n/**\n * Wraps an element in responsive intrinsic ratio elements.\n *\n * @private\n * @param  {string} embedType\n *         The type of the embed.\n *\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} el\n *         The DOM element.\n *\n * @return {Element}\n *         A new element (if needed).\n */\n\n\nvar wrapResponsive = function wrapResponsive(embedType, embedOptions, el) {\n  if (!embedOptions.responsive) {\n    return el;\n  }\n\n  el.style.position = 'absolute';\n  el.style.top = '0px';\n  el.style.right = '0px';\n  el.style.bottom = '0px';\n  el.style.left = '0px';\n  el.style.width = '100%';\n  el.style.height = '100%';\n\n  var responsive = _extends$1({\n    aspectRatio: DEFAULT_ASPECT_RATIO,\n    iframeHorizontalPlaylist: DEFAULT_IFRAME_HORIZONTAL_PLAYLIST,\n    maxWidth: DEFAULT_MAX_WIDTH\n  }, embedOptions.responsive); // This value is validate at a higher level, so we can trust that it's in the\n  // correct format.\n\n\n  var aspectRatio = responsive.aspectRatio.split(':').map(Number);\n  var inner = document.createElement('div');\n  var paddingTop = aspectRatio[1] / aspectRatio[0] * 100; // For iframes with a horizontal playlist, the playlist takes up 20% of the\n  // vertical space (if shown); so, adjust the vertical size of the embed to\n  // avoid black bars.\n\n  if (embedType === EMBED_TYPE_IFRAME && responsive.iframeHorizontalPlaylist) {\n    paddingTop *= 1.25;\n  }\n\n  inner.style.paddingTop = paddingTop + '%';\n  inner.appendChild(el);\n  var outer = document.createElement('div');\n  outer.style.position = 'relative';\n  outer.style.display = 'block';\n  outer.style.maxWidth = responsive.maxWidth;\n  outer.appendChild(inner);\n  return outer;\n};\n/**\n * Wraps an element in a Picture-in-Picture plugin container.\n *\n * @private\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} el\n *         The DOM element.\n *\n * @return {Element}\n *         A new element (if needed).\n */\n\n\nvar wrapPip = function wrapPip(embedOptions, el) {\n  if (!embedOptions.pip) {\n    return el;\n  }\n\n  var pip = document.createElement('div');\n  pip.classList.add('vjs-pip-container');\n  pip.appendChild(el);\n  return pip;\n};\n/**\n * Wraps a bare embed element with necessary parent elements, depending on\n * embed options given in params.\n *\n * @private\n * @param  {string} embedType\n *         The type of the embed.\n *\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         A new element (if needed) or the embed itself.\n */\n\n\nvar wrapEmbed = function wrapEmbed(embedType, embedOptions, embed) {\n  if (!embedOptions) {\n    return embed;\n  }\n\n  return wrapPip(embedOptions, wrapResponsive(embedType, embedOptions, embed));\n};\n/**\n * Inserts a previously-created embed element into the page based on params.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         The embed DOM element.\n */\n\n\nvar insertEmbed = function insertEmbed(params, embed) {\n  var refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert;\n  var refNodeParent = refNode.parentNode; // Wrap the embed, if needed, in container elements to support various\n  // plugins.\n\n  var wrapped = wrapEmbed(params.embedType, params.embedOptions, embed); // Decide where to insert the wrapped embed.\n\n  if (refNodeInsert === REF_NODE_INSERT_BEFORE) {\n    refNodeParent.insertBefore(wrapped, refNode);\n  } else if (refNodeInsert === REF_NODE_INSERT_AFTER) {\n    refNodeParent.insertBefore(wrapped, refNode.nextElementSibling || null);\n  } else if (refNodeInsert === REF_NODE_INSERT_REPLACE) {\n    refNodeParent.replaceChild(wrapped, refNode);\n  } else if (refNodeInsert === REF_NODE_INSERT_PREPEND) {\n    refNode.insertBefore(wrapped, refNode.firstChild || null); // Append is the default.\n  } else {\n    refNode.appendChild(wrapped);\n  } // If the playlist embed option is provided, we need to add a playlist element\n  // immediately after the embed. This has to happen after the embed is inserted\n  // into the DOM (above).\n\n\n  if (params.embedOptions && params.embedOptions.playlist) {\n    var playlistTagName = params.embedOptions.playlist.legacy ? 'ul' : 'div';\n    var playlist = document.createElement(playlistTagName);\n    playlist.classList.add('vjs-playlist');\n    embed.parentNode.insertBefore(playlist, embed.nextElementSibling || null);\n  } // Clean up internal reference to the refNode to avoid potential memory\n  // leaks in case the params get persisted somewhere. We won't need it beyond\n  // this point.\n\n\n  params.refNode = null; // Return the original embed element that can be passed to `bc()`.\n\n  return embed;\n};\n/**\n * Handles `onEmbedCreated` callback invocation.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         A possibly-new DOM element.\n */\n\n\nvar onEmbedCreated = function onEmbedCreated(params, embed) {\n  if (typeof params.onEmbedCreated !== 'function') {\n    return embed;\n  }\n\n  var result = params.onEmbedCreated(embed);\n\n  if (isEl(result)) {\n    return result;\n  }\n\n  return embed;\n};\n/**\n * Creates an embed code of the appropriate type, runs any customizations\n * necessary, and inserts it into the DOM.\n *\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()`\n *         function. Even when customized or wrapped, the return value will be\n *         the target element.\n */\n\n\nvar createEmbed = function createEmbed(params) {\n  var embed = params.embedType === EMBED_TYPE_IFRAME ? createIframeEmbed(params) : createInPageEmbed(params);\n  return insertEmbed(params, onEmbedCreated(params, embed));\n};\n\n//\n// The keys follow the format \"accountId_playerId_embedId\" where accountId is\n// optional and defaults to \"*\". This happens when we detect pre-existing\n// player globals.\n\nvar actualCache = new window.Map();\n/**\n * Get the cache key given some properties.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {string}\n *         A key to be used in the script cache.\n */\n\nvar key = function key(_ref) {\n  var accountId = _ref.accountId,\n      playerId = _ref.playerId,\n      embedId = _ref.embedId;\n  return (accountId || '*') + \"_\" + playerId + \"_\" + embedId;\n};\n/**\n * Add an entry to the script cache.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID. If not given, we assume that no script was\n *         downloaded for this player.\n */\n\n\nvar store = function store(props) {\n  actualCache.set(key(props), props.accountId ? urls.getUrl(props) : '');\n};\n/**\n * Checks if the script cache has an entry.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {boolean}\n *         Will be `true` if there is a matching cache entry.\n */\n\n\nvar has = function has(props) {\n  return actualCache.has(key(props));\n};\n/**\n * Gets a cache entry.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {string}\n *         A cache entry - a URL or empty string.\n *\n */\n\n\nvar get = function get(props) {\n  return actualCache.get(key(props));\n};\n/**\n * Clears the cache.\n */\n\n\nvar clear = function clear() {\n  actualCache.clear();\n};\n/**\n * Iterates over the cache.\n *\n * @param  {Function} fn\n *         A callback function that will be called with a value and a key\n *         for each item in the cache.\n */\n\n\nvar forEach = function forEach(fn) {\n  actualCache.forEach(fn);\n};\n\nvar playerScriptCache = {\n  clear: clear,\n  forEach: forEach,\n  get: get,\n  has: has,\n  key: key,\n  store: store\n};\n\nvar REGEX_PLAYER_EMBED = /^([A-Za-z0-9]+)_([A-Za-z0-9]+)$/;\n/**\n * Gets an array of current per-player/per-embed `bc` globals that are\n * attached to the `bc` global (e.g. `bc.abc123xyz_default`).\n *\n * If `bc` is not defined, returns an empty array.\n *\n * @private\n * @return {string[]}\n *         An array of keys.\n */\n\nvar getBcGlobalKeys = function getBcGlobalKeys() {\n  return window.bc ? Object.keys(window.bc).filter(function (k) {\n    return REGEX_PLAYER_EMBED.test(k);\n  }) : [];\n};\n/**\n * Gets known global object keys that Brightcove Players may create.\n *\n * @private\n * @return {string[]}\n *         An array of global variables that were added during testing.\n */\n\n\nvar getGlobalKeys = function getGlobalKeys() {\n  return Object.keys(window).filter(function (k) {\n    return /^videojs/i.test(k) || /^(bc)$/.test(k);\n  });\n};\n/**\n * Dispose all players from a copy of Video.js.\n *\n * @param  {Function} videojs\n *         A copy of Video.js.\n */\n\n\nvar disposeAll = function disposeAll(videojs) {\n  if (!videojs) {\n    return;\n  }\n\n  Object.keys(videojs.players).forEach(function (k) {\n    var p = videojs.players[k];\n\n    if (p) {\n      p.dispose();\n    }\n  });\n};\n/**\n * Resets environment state.\n *\n * This will dispose ALL Video.js players on the page and remove ALL `bc` and\n * `videojs` globals it finds.\n */\n\n\nvar reset = function reset() {\n  // Remove all script elements from the DOM.\n  playerScriptCache.forEach(function (value, key) {\n    // If no script URL is associated, skip it.\n    if (!value) {\n      return;\n    } // Find all script elements and remove them.\n\n\n    Array.prototype.slice.call(document.querySelectorAll(\"script[src=\\\"\" + value + \"\\\"]\")).forEach(function (el) {\n      return el.parentNode.removeChild(el);\n    });\n  }); // Clear the internal cache that have been downloaded.\n\n  playerScriptCache.clear(); // Dispose any remaining players from the `videojs` global.\n\n  disposeAll(window.videojs); // There may be other `videojs` instances lurking in the bowels of the\n  // `bc` global. This should eliminate any of those.\n\n  getBcGlobalKeys().forEach(function (k) {\n    return disposeAll(window.bc[k].videojs);\n  }); // Delete any global object keys that were created.\n\n  getGlobalKeys().forEach(function (k) {\n    delete window[k];\n  });\n};\n/**\n * At runtime, populate the cache with pre-detected players. This allows\n * people who have bundled their player or included a script tag before this\n * runs to not have to re-download players.\n */\n\n\nvar detectPlayers = function detectPlayers() {\n  getBcGlobalKeys().forEach(function (k) {\n    var matches = k.match(REGEX_PLAYER_EMBED);\n    var props = {\n      playerId: matches[1],\n      embedId: matches[2]\n    };\n\n    if (!playerScriptCache.has(props)) {\n      playerScriptCache.store(props);\n    }\n  });\n};\n\nvar env = {\n  detectPlayers: detectPlayers,\n  reset: reset\n};\n\nenv.detectPlayers();\n/**\n * Is this value a function?\n *\n * @private\n * @param  {Function} fn\n *         A maybe function.\n *\n * @return {boolean}\n *         Whether or not the value is a function.\n */\n\nvar isFn = function isFn(fn) {\n  return typeof fn === 'function';\n};\n/**\n * Checks whether an embedType parameter is valid.\n *\n * @private\n * @param  {string} embedType\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidEmbedType = function isValidEmbedType(embedType) {\n  return embedType === EMBED_TYPE_IN_PAGE || embedType === EMBED_TYPE_IFRAME;\n};\n/**\n * Checks whether an embedOptions.tagName parameter is valid.\n *\n * @private\n * @param  {string} tagName\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidTagName = function isValidTagName(tagName) {\n  return tagName === EMBED_TAG_NAME_VIDEOJS || tagName === EMBED_TAG_NAME_VIDEO;\n};\n/**\n * Checks whether a refNodeInsert parameter is valid.\n *\n * @private\n * @param  {string} refNodeInsert\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidRootInsert = function isValidRootInsert(refNodeInsert) {\n  return refNodeInsert === REF_NODE_INSERT_APPEND || refNodeInsert === REF_NODE_INSERT_PREPEND || refNodeInsert === REF_NODE_INSERT_BEFORE || refNodeInsert === REF_NODE_INSERT_AFTER || refNodeInsert === REF_NODE_INSERT_REPLACE;\n};\n/**\n * Checks parameters and throws an error on validation problems.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @throws {Error} If accountId is missing.\n * @throws {Error} If refNode is missing or invalid.\n * @throws {Error} If embedType is missing or invalid.\n * @throws {Error} If attempting to use an iframe embed with options.\n * @throws {Error} If attempting to use embedOptions.responsiveIframe with a\n *                 non-iframe embed.\n * @throws {Error} If refNodeInsert is missing or invalid.\n */\n\n\nvar checkParams = function checkParams(params) {\n  var accountId = params.accountId,\n      embedOptions = params.embedOptions,\n      embedType = params.embedType,\n      options = params.options,\n      refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert;\n\n  if (!accountId) {\n    throw new Error('accountId is required');\n  } else if (!isElInDom(refNode)) {\n    throw new Error('refNode must resolve to a node attached to the DOM');\n  } else if (!isValidEmbedType(embedType)) {\n    throw new Error('embedType is missing or invalid');\n  } else if (embedType === EMBED_TYPE_IFRAME && options) {\n    throw new Error('cannot use options with an iframe embed');\n  } else if (embedOptions && embedOptions.tagName !== undefined && !isValidTagName(embedOptions.tagName)) {\n    throw new Error(\"embedOptions.tagName is invalid (value: \\\"\" + embedOptions.tagName + \"\\\")\");\n  } else if (embedOptions && embedOptions.responsive && embedOptions.responsive.aspectRatio && !/^\\d+\\:\\d+$/.test(embedOptions.responsive.aspectRatio)) {\n    throw new Error(\"embedOptions.responsive.aspectRatio must be in the \\\"n:n\\\" format (value: \\\"\" + embedOptions.responsive.aspectRatio + \"\\\")\");\n  } else if (!isValidRootInsert(refNodeInsert)) {\n    throw new Error('refNodeInsert is missing or invalid');\n  }\n};\n/**\n * Normalizes a `refNode` param to an element - or `null`.\n *\n * @private\n * @param  {Element|string} refNode\n *         The value of a `refNode` param.\n *\n * @return {Element|null}\n *         A DOM element or `null` if the `refNode` was given as a string and\n *         did not match an element.\n */\n\n\nvar resolveRefNode = function resolveRefNode(refNode) {\n  if (isElInDom(refNode)) {\n    return refNode;\n  }\n\n  if (typeof refNode === 'string') {\n    return document.querySelector(refNode);\n  }\n\n  return null;\n};\n/**\n * Initializes a player and returns it.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         An element that will be passed to the `bc()` function.\n *\n * @param  {Function} resolve\n *         A function to call if a player is successfully initialized.\n *\n * @param  {Function} reject\n *         A function to call if a player fails to be initialized.\n *\n * @return {Object}\n *         A success object whose `ref` is a player.\n */\n\n\nvar initPlayer = function initPlayer(params, embed, resolve, reject) {\n  var embedId = params.embedId,\n      playerId = params.playerId;\n  var bc = window.bc[playerId + \"_\" + embedId] || window.bc;\n\n  if (!bc) {\n    return reject(new Error(\"missing bc function for \" + playerId));\n  }\n\n  playerScriptCache.store(params);\n  var player;\n\n  try {\n    player = bc(embed, params.options); // Add a PLAYER_LOADER property to bcinfo to indicate this player was\n    // loaded via that mechanism.\n\n    if (player.bcinfo) {\n      player.bcinfo.PLAYER_LOADER = true;\n    }\n  } catch (x) {\n    var message = 'Could not initialize the Brightcove Player.'; // Update the rejection message based on known conditions that can cause it.\n\n    if (params.embedOptions.tagName === EMBED_TAG_NAME_VIDEOJS) {\n      message += ' You are attempting to embed using a \"video-js\" element.' + ' Please ensure that your Player is v6.11.0 or newer in order to' + ' support this embed type. Alternatively, pass `\"video\"` for' + ' `embedOptions.tagName`.';\n    }\n\n    return reject(new Error(message));\n  }\n\n  resolve({\n    type: EMBED_TYPE_IN_PAGE,\n    ref: player\n  });\n};\n/**\n * Loads a player from CDN and embeds it.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Function} resolve\n *         A function to call if a player is successfully initialized.\n *\n * @param  {Function} reject\n *         A function to call if a player fails to be initialized.\n */\n\n\nvar loadPlayer = function loadPlayer(params, resolve, reject) {\n  params.refNode = resolveRefNode(params.refNode);\n  checkParams(params);\n  var refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert; // Store a reference to the refNode parent. When we use the replace method,\n  // we'll need it as the location to store the script element.\n\n  var refNodeParent = refNode.parentNode;\n  var embed = createEmbed(params); // If this is an iframe, all we need to do is create the embed code and\n  // inject it. Because there is no reliable way to hook into an iframe from\n  // the parent page, we simply resolve immediately upon creating the embed.\n\n  if (params.embedType === EMBED_TYPE_IFRAME) {\n    resolve({\n      type: EMBED_TYPE_IFRAME,\n      ref: embed\n    });\n    return;\n  } // If we've already downloaded this script or detected a matching global, we\n  // should have the proper `bc` global and can bypass the script creation\n  // process.\n\n\n  if (playerScriptCache.has(params)) {\n    return initPlayer(params, embed, resolve, reject);\n  }\n\n  var script = document.createElement('script');\n\n  script.onload = function () {\n    return initPlayer(params, embed, resolve, reject);\n  };\n\n  script.onerror = function () {\n    reject(new Error('player script could not be downloaded'));\n  };\n\n  script.async = true;\n  script.charset = 'utf-8';\n  script.src = urls.getUrl(params);\n\n  if (refNodeInsert === REF_NODE_INSERT_REPLACE) {\n    refNodeParent.appendChild(script);\n  } else {\n    refNode.appendChild(script);\n  }\n};\n/**\n * A function for asynchronously loading a Brightcove Player into a web page.\n *\n * @param  {Object} parameters\n *         A parameters object. See README for details.\n *\n * @return {Promise|undefined}\n *         A Promise, if possible.\n */\n\n\nvar brightcovePlayerLoader = function brightcovePlayerLoader(parameters) {\n  var params = _extends$1({}, DEFAULTS, parameters);\n\n  var Promise = params.Promise,\n      onSuccess = params.onSuccess,\n      onFailure = params.onFailure; // When Promise is not available or any success/failure callback is given,\n  // do not attempt to use Promises.\n\n  if (!isFn(Promise) || isFn(onSuccess) || isFn(onFailure)) {\n    return loadPlayer(params, isFn(onSuccess) ? onSuccess : function () {}, isFn(onFailure) ? onFailure : function (err) {\n      throw err;\n    });\n  } // Promises are supported, use 'em.\n\n\n  return new Promise(function (resolve, reject) {\n    return loadPlayer(params, resolve, reject);\n  });\n};\n/**\n * Expose a non-writable, non-configurable property on the\n * `brightcovePlayerLoader` function.\n *\n * @private\n * @param  {string} key\n *         The property key.\n *\n * @param  {string|Function} value\n *         The value.\n */\n\n\nvar expose = function expose(key, value) {\n  Object.defineProperty(brightcovePlayerLoader, key, {\n    configurable: false,\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n};\n/**\n * Get the base URL for players. By default, this will be the Brightcove CDN.\n *\n * @return {string}\n *         The current base URL.\n */\n\n\nexpose('getBaseUrl', function () {\n  return urls.getBaseUrl();\n});\n/**\n * Set the base URL for players. By default, this will be the Brightcove CDN,\n * but can be overridden with this function.\n *\n * @param {string} baseUrl\n *        A new base URL (instead of Brightcove CDN).\n */\n\nexpose('setBaseUrl', function (baseUrl) {\n  urls.setBaseUrl(baseUrl);\n});\n/**\n * Get the URL for a player.\n */\n\nexpose('getUrl', function (options) {\n  return urls.getUrl(options);\n});\n/**\n * Completely resets global state.\n *\n * This will dispose ALL Video.js players on the page and remove ALL `bc` and\n * `videojs` globals it finds.\n */\n\nexpose('reset', function () {\n  return env.reset();\n}); // Define some read-only constants on the exported function.\n\n[['EMBED_TAG_NAME_VIDEO', EMBED_TAG_NAME_VIDEO], ['EMBED_TAG_NAME_VIDEOJS', EMBED_TAG_NAME_VIDEOJS], ['EMBED_TYPE_IN_PAGE', EMBED_TYPE_IN_PAGE], ['EMBED_TYPE_IFRAME', EMBED_TYPE_IFRAME], ['REF_NODE_INSERT_APPEND', REF_NODE_INSERT_APPEND], ['REF_NODE_INSERT_PREPEND', REF_NODE_INSERT_PREPEND], ['REF_NODE_INSERT_BEFORE', REF_NODE_INSERT_BEFORE], ['REF_NODE_INSERT_AFTER', REF_NODE_INSERT_AFTER], ['REF_NODE_INSERT_REPLACE', REF_NODE_INSERT_REPLACE], ['VERSION', version]].forEach(function (arr) {\n  expose(arr[0], arr[1]);\n});\n\n/**\n * These prop changes can be handled by an internal player state change rather\n * than a full dispose/recreate.\n *\n * @private\n * @type {Object}\n */\n\nvar UPDATEABLE_PROPS = ['catalogSearch', 'catalogSequence', 'playlistId', 'playlistVideoId', 'videoId'];\n\nvar logError = function logError(err) {\n  /* eslint-disable no-console */\n  if (err && console && console.error) {\n    console.error(err);\n  }\n  /* eslint-enable no-console */\n\n};\n/**\n * The official React component for the Brightcove Player!\n *\n * This uses `@brightcove/player-loader` to load a player into a React\n * component based on the given props.\n */\n\n\nvar ReactPlayerLoader =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(ReactPlayerLoader, _React$Component);\n\n  /**\n   * Create a new Brightcove player.\n   *\n   * @param {Object} props\n   *        Most options will be passed along to player-loader, except for\n   *        options that are listed. See README.md for more detail.\n   *\n   * @param {string} [props.baseUrl]\n   *        The base URL to use when requesting a player\n   *\n   * @param {Object} [props.attrs]\n   *        Used to set attributes on the component element that contains the\n   *        embedded Brightcove Player.\n   */\n  function ReactPlayerLoader(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.refNode = null;\n\n    _this.setRefNode = function (ref) {\n      _this.refNode = ref;\n    };\n\n    return _this;\n  }\n  /**\n   * Loads a new player based on the current props.\n   */\n\n\n  var _proto = ReactPlayerLoader.prototype;\n\n  _proto.loadPlayer = function loadPlayer() {\n    var _this2 = this;\n\n    // If there is any player currently loaded, dispose it before fetching a\n    // new one.\n    this.disposePlayer(); // We need to provide our own callbacks below, so we cache these\n    // user-provided callbacks for use later.\n\n    var userSuccess = this.props.onSuccess;\n    var userFailure = this.props.onFailure;\n\n    var options = _extends({}, this.props, {\n      refNode: this.refNode,\n      refNodeInsert: 'append',\n      onSuccess: function onSuccess(_ref) {\n        var ref = _ref.ref,\n            type = _ref.type;\n\n        // If the component is not mounted when the callback fires, dispose\n        // the player and bail out.\n        if (!_this2.isMounted_) {\n          _this2.disposePlayer(ref);\n\n          return;\n        } // Store a player reference on the component.\n\n\n        _this2.player = ref; // Null out the player reference when the player is disposed from\n        // outside the component.\n\n        if (type === 'in-page') {\n          ref.one('dispose', function () {\n            _this2.player = null;\n          });\n        } // Add a REACT_PLAYER_LOADER property to bcinfo to indicate this player\n        // was loaded via that mechanism.\n\n\n        if (ref.bcinfo) {\n          ref.bcinfo.REACT_PLAYER_LOADER = true;\n        } // Call a user-provided onSuccess callback.\n\n\n        if (typeof userSuccess === 'function') {\n          userSuccess({\n            ref: ref,\n            type: type\n          });\n        }\n      },\n      onFailure: function onFailure(error) {\n        // Ignore errors when not mounted.\n        if (!_this2.isMounted_) {\n          return;\n        } // Call a user-provided onFailure callback.\n\n\n        if (typeof userFailure === 'function') {\n          userFailure(error);\n          return;\n        } // Fall back to throwing an error;\n\n\n        throw new Error(error);\n      }\n    }); // Delete props that are not meant to be passed to player-loader.\n\n\n    delete options.attrs;\n    delete options.baseUrl; // If a base URL is provided, it should only apply to this player load.\n    // This means we need to back up the original base URL and restore it\n    // _after_ we call player loader.\n\n    var originalBaseUrl = brightcovePlayerLoader.getBaseUrl();\n\n    if (this.props.baseUrl) {\n      brightcovePlayerLoader.setBaseUrl(this.props.baseUrl);\n    }\n\n    brightcovePlayerLoader(options);\n    brightcovePlayerLoader.setBaseUrl(originalBaseUrl);\n  }\n  /**\n   * Disposes the current player, if there is one.\n   */\n  ;\n\n  _proto.disposePlayer = function disposePlayer() {\n    // Nothing to dispose.\n    if (!this.player) {\n      return;\n    } // Dispose an in-page player.\n\n\n    if (this.player.dispose) {\n      this.player.dispose(); // Dispose an iframe player.\n    } else if (this.player.parentNode) {\n      this.player.parentNode.removeChild(this.player);\n    } // Null out the player reference.\n\n\n    this.player = null;\n  }\n  /**\n   * Find the index of the `playlistVideoId` prop within the player's playlist.\n   *\n   * @param  {Object[]} playlist\n   *         An array of playlist item objects.\n   *\n   * @return {number}\n   *         The index of the `playlistVideoId` or `-1` if the player has been\n   *         disposed, is not using the playlist plugin, or if not found.\n   */\n  ;\n\n  _proto.findPlaylistVideoIdIndex_ = function findPlaylistVideoIdIndex_(playlist) {\n    var playlistVideoId = this.props.playlistVideoId;\n\n    if (Array.isArray(playlist) && playlistVideoId) {\n      for (var i = 0; i < playlist.length; i++) {\n        var _playlist$i = playlist[i],\n            id = _playlist$i.id,\n            referenceId = _playlist$i.referenceId;\n\n        if (id === playlistVideoId || \"ref:\" + referenceId === playlistVideoId) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Create a Playback API callback function for the component's player.\n   *\n   * @private\n   * @param  {string} requestType\n   *         The Playback API request type (e.g. \"video\" or \"playlist\").\n   *\n   * @param  {Object} changes\n   *         An object. The keys of this object are the props that changed.\n   *\n   * @return {Function}\n   *         A callback for the Playback API request.\n   */\n  ;\n\n  _proto.createPlaybackAPICallback_ = function createPlaybackAPICallback_(requestType, changes) {\n    var _this3 = this;\n\n    return function (err, data) {\n      if (err) {\n        logError(err);\n        return;\n      } // If the playlistVideoId changed and this is a playlist request, we\n      // need to search through the playlist items to find the correct\n      // starting index.\n\n\n      if (requestType === 'playlist' && changes.playlistVideoId) {\n        var i = _this3.findPlaylistVideoIdIndex_(data);\n\n        if (i > -1) {\n          data.startingIndex = i;\n        }\n      }\n\n      _this3.player.catalog.load(data);\n    };\n  }\n  /**\n   * Update the player based on changes to certain props that do not require\n   * a full player dispose/recreate.\n   *\n   * @param {Object} changes\n   *        An object. The keys of this object are the props that changed.\n   */\n  ;\n\n  _proto.updatePlayer = function updatePlayer(changes) {\n    // No player exists, player is disposed, or not using the catalog\n    if (!this.player || !this.player.el()) {\n      return;\n    } // If the player is using the catalog plugin, we _may_ populate this\n    // variable with an object.\n\n\n    var catalogParams;\n\n    if (this.player.usingPlugin('catalog')) {\n      // There is a new catalog sequence request. This takes precedence over\n      // other catalog updates because it is a different call.\n      if (changes.catalogSequence && this.props.catalogSequence) {\n        var callback = this.createPlaybackAPICallback_('sequence', changes);\n        this.player.catalog.getLazySequence(this.props.catalogSequence, callback, this.props.adConfigId);\n        return;\n      }\n\n      if (changes.videoId && this.props.videoId) {\n        catalogParams = {\n          type: 'video',\n          id: this.props.videoId\n        };\n      } else if (changes.playlistId && this.props.playlistId) {\n        catalogParams = {\n          type: 'playlist',\n          id: this.props.playlistId\n        };\n      } else if (changes.catalogSearch && this.props.catalogSearch) {\n        catalogParams = {\n          type: 'search',\n          q: this.props.catalogSearch\n        };\n      }\n    } // If `catalogParams` is `undefined` here, that means the player either\n    // does not have the catalog plugin or no valid catalog request can be made.\n\n\n    if (catalogParams) {\n      if (this.props.adConfigId) {\n        catalogParams.adConfigId = this.props.adConfigId;\n      }\n\n      if (this.props.deliveryConfigId) {\n        catalogParams.deliveryConfigId = this.props.deliveryConfigId;\n      } // We use the callback style here to make tests simpler in IE11 (no need\n      // for a Promise polyfill).\n\n\n      var _callback = this.createPlaybackAPICallback_(catalogParams.type, changes);\n\n      this.player.catalog.get(catalogParams, _callback); // If no catalog request is being made, we may still need to update the\n      // playlist selected video.\n    } else if (changes.playlistVideoId && this.props.playlistVideoId && this.player.usingPlugin('playlist')) {\n      var i = this.findPlaylistVideoIdIndex_(this.player.playlist());\n\n      if (i > -1) {\n        this.player.playlist.currentItem(i);\n      }\n    }\n  }\n  /**\n   * Called just after the component has mounted.\n   */\n  ;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.isMounted_ = true;\n    this.loadPlayer();\n  }\n  /**\n   * Called when the component props are updated.\n   *\n   * Some prop changes may trigger special behavior (see `propChangeHandlers`),\n   * but if ANY prop is changed that is NOT handled, the player will be\n   * disposed/recreated entirely.\n   *\n   * @param  {Object} prevProps\n   *         The previous props state before change.\n   */\n  ;\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this4 = this;\n\n    // Calculate the prop changes.\n    var changes = Object.keys(prevProps).reduce(function (acc, key) {\n      var previous = prevProps[key];\n      var current = _this4.props[key];\n\n      if (current !== previous) {\n        acc[key] = true;\n      }\n\n      return acc;\n    }, {}); // Dispose and recreate the player if any changed keys cannot be handled.\n\n    if (Object.keys(changes).some(function (k) {\n      return UPDATEABLE_PROPS.indexOf(k) === -1;\n    })) {\n      this.loadPlayer();\n      return;\n    }\n\n    this.updatePlayer(changes);\n  }\n  /**\n   * Called just before a component unmounts. Disposes the player.\n   */\n  ;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.isMounted_ = false;\n    this.disposePlayer();\n  }\n  /**\n   * Renders the component.\n   *\n   * @return {ReactElement}\n   *          The react element to render.\n   */\n  ;\n\n  _proto.render = function render() {\n    var props = _extends({\n      className: 'brightcove-react-player-loader'\n    }, this.props.attrs, {\n      ref: this.setRefNode\n    });\n\n    return React.createElement('div', props);\n  };\n\n  return ReactPlayerLoader;\n}(React.Component);\n\nexport default ReactPlayerLoader;\n"]},"metadata":{},"sourceType":"module"}